#+title: Moonli - A syntax layer that transpiles to Common Lisp

* What
:PROPERTIES:
:CUSTOM_ID: what
:END:

This is a syntax layer that transpiles to Common Lisp.

#+begin_src
defun sum(args):
  if null(args):
    0
  else:
    first(args) + sum(rest(args))
  end
end
#+end_src

transpiles to:

#+begin_src lisp
(defun sum (args)
   (cond ((null args)
          0)
         (t
          (+ (first args)
             (sum (rest args))))))
#+end_src

See [[./moonli-sample.asd]] and [[./sample/sample.moonli]] to include in your project.

#+attr_html: :width 640px
[[./repl/repl.gif]]

* Table of Contents
:PROPERTIES:
:TOC:      :include all :depth 4 :ignore this
:CUSTOM_ID: table-of-contents
:END:

:CONTENTS:
- [[#what][What]]
- [[#why][Why]]
- [[#features][Features]]
  - [[#for-common-lispers][For common lispers]]
  - [[#for-programmers-in-general][For programmers in general]]
- [[#plan][Plan]]
- [[#syntax][Syntax]]
  - [[#global-variables][Global variables]]
  - [[#local-variables][Local variables]]
  - [[#symbols][Symbols]]
  - [[#function-like-calls][Function-like calls]]
  - [[#functions][Functions]]
  - [[#dictionaries-or-hash-tables][Dictionaries or Hash-tables]]
  - [[#sets-or-hash-sets][Sets or Hash-sets]]
  - [[#infix-operators][Infix operators]]
  - [[#lm][lm]]
  - [[#declaim][declaim]]
  - [[#declare][declare]]
  - [[#ifelse][ifelse]]
  - [[#lambda][lambda]]
  - [[#let-pluslet][let-plus:let+]]
  - [[#loop][loop]]
  - [[#defun][defun]]
  - [[#if][if]]
  - [[#let][let]]
  - [[#forfor][for:for]]
:END:

* Why
:PROPERTIES:
:CUSTOM_ID: why
:END:

Due to tools like [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][paredit]] and [[https://github.com/abo-abo/lispy][lispy]] (beyond [[https://lispcookbook.github.io/cl-cookbook/macros.html][macros]] and metaprogramming), s-expression (Lists) based syntax of lisps is very powerful. However, not every one has the time or patience to become comfortable with them, especially when it comes to reading code, or sharing it with your colleagues.

In the 21st century, very many more people are familiar with python, matlab and julia than they are with lisps. Given the power and flexibility of common lisp, =moonli= is an attempt to provide a thin syntax layer over common lisp. It is thin in the sense it can be easily transpiled to common lisp. The semantics remain the same and clean as common lisp. ([[https://common-lisp.net/][Common Lisp]] is also good for [[https://www.quora.com/What-is-your-favourite-non-mainstream-programming-language/answer/Shubhamkar-Ayare][reasons beyond macros]].)



* Features
:PROPERTIES:
:CUSTOM_ID: features
:END:

** For common lispers
:PROPERTIES:
:CUSTOM_ID: for-common-lispers
:END:

- Case sensitive, but invert-case reader to maintain common lisp compatibility
- Transpile to common lisp, so lispers need not "learn a new language"
- Extensible using =moonli:define-moonli-macro= and =moonli:define-short-moonli-macro=. See [[./src/macros/]] directory for examples.
- Inability to access internal symbols of another package through "A::B" syntax; this syntax rather translates to =(the B A)=

** For programmers in general
:PROPERTIES:
:CUSTOM_ID: for-programmers-in-general
:END:

- Sane variable scoping rules as given by common lisp
- Sane namespace scoping thanks to common lisp package system
- Sane restarts and condition system thanks to common lisp
- Optional typing, optional dynamic scoping
- Availability of optimizing compilers such as SBCL
- Sensitive to newlines and semicolons but not to spaces and tabs (indentation insensitive)
- Returning multiple values without an intermediate data structure
- Support for rapid prototyping through CLOS and image-based development

Here's a brief comparison of features across different languages.

| *Features*                          |  *Moonli*  | *Common Lisp* |   *Julia*   |  *Haskell*  |     *Rust*     |  *Python*   | *Javascript* |     *C*     |
|                                   |   <c>    |     <c>     |    <c>    |    <c>    |     <c>      |    <c>    |    <c>     |    <c>    |
|-----------------------------------+----------+-------------+-----------+-----------+--------------+-----------+------------+-----------|
| Syntax                            |    +     |      +      |     +     |     +     |     ---      |     +     |     -      |     -     |
| Interactivity (Rapid Prototyping) |   High   |  Very High  | Moderate  |    Low    |     None     | Moderate  |  Moderate  |   None    |
| Typing (Strong/Weak)              |  Strong  |   Strong    |  Strong   |  Strong   |    Strong    |  Strong   |    Weak    |   Weak    |
| Typing (Static/Dynamic)           | Flexible |  Flexible   | Flexible  |  Static   |    Static    |  Dynamic  |  Dynamic   |  Dynamic  |
| Typing (Expressivity)             | Flexible |  Flexible   | Moderate  | Very High |  Very High   |    Low    |    Low     |    Low    |
| Compiler Speed                    | Flexible |  Flexible   |   Slow    | Moderate  |     Slow     | Moderate  |  Moderate  | Moderate  |
| Runtime Speed                     | Flexible |  Flexible   |   Fast    | Moderate  |     Fast     |   Slow    |  Moderate  |   Fast    |
| Runtime Error Recovery            | Advanced |  Advanced   |  Limited  | Moderate  |     None     | Moderate  |  Moderate  |   None    |
| Binary Size                       | Flexible |  Flexible   |   Large   |     ?     |    Small     |   None    |    None    |   Small   |
| User Extensibility                |   High   |    High     | Moderate  |    Low    |     Low      |   None    |    None    |   None    |
| Compiler built-in optimizations   |   Low    |     Low     | Very High |     ?     |  Very High   |    Low    |  Moderate  | Very High |
| Long Term Support                 |   Low    |  Very High  | Moderate  |     ?     |   Moderate   | Moderate  |    Low     | Very High |
| Ecosystem (without interop)       |  Small   |    Small    | Moderate  |   Small   |   Moderate   |   Large   |   Large    |   Large   |
| Memory Management                 |   Heap   |    Heap     | Reference |   Heap    | Compile Time | Reference |     ?      |  Manual   |

* Plan
:PROPERTIES:
:CUSTOM_ID: plan
:END:

- DONE Real numbers, strings, characters, lists, infix arithmetic operators, literal hash-tables, literal hash-sets
- DONE Typing using "expr::type" operator
- DONE Support for declare and declaim
- TODO Literal syntax for vectors, array access
- DONE BODMAS rule for parsing expressions
- DONE Binaries
- TODO VS Code integration
- TODO Emacs mode and integration with slime
- DONE Infix Logical operators
- TODO Add more forms: progn, mvb, dsb, let+, more...
- TODO Add more tests
- TODO Reverse transpile from common lisp

* Syntax
:PROPERTIES:
:CUSTOM_ID: syntax
:END:

As with lisp, everything is an expression.

Simple syntax table:

| Lisp                     | Moonli                  |
|--------------------------+-------------------------|
| #\a                      | 'a'                     |
| "hello world"            | "hello world"           |
| 2, 2.0, 2d-3, 2.0d-3     | 2, 2.0, 2d-3, 2.0d-3    |
| 'quoted-symbol           | $quoted-symbol          |
| package:exported-symbol  | package:exported-symbol |
| package::internal-symbol | <WONTDO>                |
| (the type expr)          | expr :: type            |
| (list form-1 form-2)     | (form-1, form-2)        |
| (fn arg1 arg2)           | fn(arg1, arg2)          |
| #c(re, im)               | <TODO>                  |

** Global variables
:PROPERTIES:
:CUSTOM_ID: global-variables
:END:

#+begin_src moonli
defparameter *global* = 23
#+end_src

** Local variables
:PROPERTIES:
:CUSTOM_ID: local-variables
:END:

#+begin_src moonli
let answer-to-everything = 42 :
  answer-to-everything
end
#+end_src

** Symbols
:PROPERTIES:
:CUSTOM_ID: symbols
:END:

Most valid symbols can be written in moonli. For example, above =*global*= and =answer-to-everything= are each single symbols. This is unlike mainstream languages where =* - ? != and several other characters are not allowed in symbols.

However, this means that symbols must be separated from each other by space. This is necessary to make a distinction between whether a character stands for an infix operation or is part of a symbol. =a+b= is a single symbol, but =a + b= is translated to the lisp expression =(+ a b)=.

** Function-like calls
:PROPERTIES:
:CUSTOM_ID: function-like-calls
:END:

#+begin_src moonli
identity("hello world")
function(identity)
#+end_src

Because lisp macros and functions follow similar syntax, moonli syntax for function calls can also be used for macro calls when the macro syntax is simple. (Indeed, this can be inconvenient; see [[defining your own]].)

#+begin_src moonli
destructuring-bind(a(b),(1,2),+(1,2))
#+end_src

transpiles to

#+begin_src lisp
(destructuring-bind (a b) (list 1 2)
  (+ 1 2))
#+end_src

** Functions
:PROPERTIES:
:CUSTOM_ID: functions
:END:

Like lisp, return is implicit.

#+begin_src moonli
defun fib(n):
  if n < 0:
     error("Don't know how to compute fib for n=~d < 0", n)
  elif n == 0 or n == 1:
     1
  else:
    fib(n-1) + fib(n-2)
  end
end
#+end_src

** Dictionaries or Hash-tables
:PROPERTIES:
:CUSTOM_ID: dictionaries-or-hash-tables
:END:

#+begin_src moonli
{
  :a : 2,
  "b": $cl:progn
}
#+end_src

transpiles to

#+begin_src lisp
(fill-hash-table (:a 2) ("b" 'progn))
#+end_src

which expands to

#+begin_src lisp
(let ((#:hash-table413 (make-hash-table :test #'equal :size 2)))
  (setf (gethash :a #:hash-table413) 2
        (gethash "b" #:hash-table413) 'progn)
  #:hash-table413)
#+end_src

** Sets or Hash-sets
:PROPERTIES:
:CUSTOM_ID: sets-or-hash-sets
:END:

#+begin_src moonli
{:a, "b" , $cl:progn}
#+end_src

transpiles to

#+begin_src lisp
(fill-hash-set :a "b" 'progn)
#+end_src

which expands to

#+begin_src lisp
(let ((#:hash-set417 (make-hash-table :test #'equal :size 3)))
  (setf (gethash :a #:hash-set417) t
        (gethash "b" #:hash-set417) t
        (gethash 'progn #:hash-set417) t)
  #:hash-set417)
#+end_src

** Infix operators
:PROPERTIES:
:CUSTOM_ID: infix-operators
:END:

The following infix operators are recognized:

- =+ - * / ^=
- =or and not=
- < <= == != >= >

** lm
:PROPERTIES:
:CUSTOM_ID: lm
:END:


#+begin_src moonli
lm (): nil
#+end_src

transpiles to

#+begin_src common-lisp
(lambda () nil)
#+end_src

#+begin_src moonli
lm (x): x
#+end_src

transpiles to

#+begin_src common-lisp
(lambda (x) x)
#+end_src

#+begin_src moonli
lm (x, y): x + y
#+end_src

transpiles to

#+begin_src common-lisp
(lambda (x y) (+ x y))
#+end_src


** declaim
:PROPERTIES:
:CUSTOM_ID: declaim
:END:


#+begin_src moonli
declaim inline(foo)
#+end_src

transpiles to

#+begin_src common-lisp
(declaim (inline foo))
#+end_src

#+begin_src moonli
declaim type(hash-table, *map*)
#+end_src

transpiles to

#+begin_src common-lisp
(declaim (type hash-table *map*))
#+end_src


** declare
:PROPERTIES:
:CUSTOM_ID: declare
:END:


#+begin_src moonli
declare type(single-float, x, y)
#+end_src

transpiles to

#+begin_src common-lisp
(declare (type single-float x y))
#+end_src

#+begin_src moonli
declare type(single-float, x, y), optimize(debug(3))
#+end_src

transpiles to

#+begin_src common-lisp
(declare (type single-float x y)
         (optimize (debug 3)))
#+end_src


** ifelse
:PROPERTIES:
:CUSTOM_ID: ifelse
:END:


#+begin_src moonli
ifelse a 5
#+end_src

transpiles to

#+begin_src common-lisp
(if a
    5
    nil)
#+end_src

#+begin_src moonli
ifelse a :hello :bye
#+end_src

transpiles to

#+begin_src common-lisp
(if a
    hello
    bye)
#+end_src


** lambda
:PROPERTIES:
:CUSTOM_ID: lambda
:END:


#+begin_src moonli
lambda (): nil end
#+end_src

transpiles to

#+begin_src common-lisp
(lambda () nil)
#+end_src

#+begin_src moonli
lambda (x):
  x
end
#+end_src

transpiles to

#+begin_src common-lisp
(lambda (x) x)
#+end_src

#+begin_src moonli
lambda (x, y):
  let sum = x + y:
    sum ^ 2
  end
end
#+end_src

transpiles to

#+begin_src common-lisp
(lambda (x y)
  (let ((sum (+ x y)))
    (expt sum 2)))
#+end_src


** let-plus:let+
:PROPERTIES:
:CUSTOM_ID: let-pluslet
:END:


#+begin_src moonli
let-plus:let+ x = 42: x
end
#+end_src

transpiles to

#+begin_src common-lisp
(let+ ((x 42))
  x)
#+end_src

#+begin_src moonli
let-plus:let+ (a,b) = list(1,2):
  a + b
end
#+end_src

transpiles to

#+begin_src common-lisp
(let+ (((a b) (list 1 2)))
  (+ a b))
#+end_src

#+begin_src moonli
let-plus:let+ let-plus:&values(a,b) = list(1,2):
  a + b
end
#+end_src

transpiles to

#+begin_src common-lisp
(let+ (((&values a b) (list 1 2)))
  (+ a b))
#+end_src

#+begin_src moonli
let-plus:let+
  let-plus:&values(a,b) = list(1,2),
  (c,d,e) = list(1,2,3):
  {a,b,c,d,e}
end
#+end_src

transpiles to

#+begin_src common-lisp
(let+ (((&values a b) (list 1 2)) ((c d e) (list 1 2 3)))
  (fill-hash-set a b c d e))
#+end_src


** loop
:PROPERTIES:
:CUSTOM_ID: loop
:END:


#+begin_src moonli
loop end loop
#+end_src

transpiles to

#+begin_src common-lisp
(loop)
#+end_src

#+begin_src moonli
loop :repeat n :do
  print("hello")
end
#+end_src

transpiles to

#+begin_src common-lisp
(loop repeat n
      do (print hello))
#+end_src

#+begin_src moonli
loop :for i :below n :do
  print(i + 1)
end
#+end_src

transpiles to

#+begin_src common-lisp
(loop for i below n
      do (print (+ i 1)))
#+end_src


** defun
:PROPERTIES:
:CUSTOM_ID: defun
:END:


#+begin_src moonli
defun our-identity(x): x end
#+end_src

transpiles to

#+begin_src common-lisp
(defun our-identity (x) x)
#+end_src

#+begin_src moonli
defun add (&rest, args):
 args
end defun
#+end_src

transpiles to

#+begin_src common-lisp
(defun add (&rest args) args)
#+end_src

#+begin_src moonli
defun add(args):
  if null(args):
    0
  else:
    first(args) + add(rest(args))
  end if
end
#+end_src

transpiles to

#+begin_src common-lisp
(defun add (args) (cond ((null args) 0) (t (+ (first args) (add (rest args))))))
#+end_src

#+begin_src moonli
defun foo(&optional, a = 5): a end
#+end_src

transpiles to

#+begin_src common-lisp
(defun foo (&optional (a 5)) a)
#+end_src


** if
:PROPERTIES:
:CUSTOM_ID: if
:END:


#+begin_src moonli
if a: b end if
#+end_src

transpiles to

#+begin_src common-lisp
(cond (a b) (t))
#+end_src

#+begin_src moonli
if a:
  b; c
end
#+end_src

transpiles to

#+begin_src common-lisp
(cond (a b c) (t))
#+end_src

#+begin_src moonli
if a: b
else: c
end if
#+end_src

transpiles to

#+begin_src common-lisp
(cond (a b) (t c))
#+end_src

#+begin_src moonli
if a:
   b; d
else:
   c; e
end if
#+end_src

transpiles to

#+begin_src common-lisp
(cond (a b d) (t c e))
#+end_src

#+begin_src moonli
if a: b
elif c: d; e
else: f
end if
#+end_src

transpiles to

#+begin_src common-lisp
(cond (a b) (c d e) (t f))
#+end_src

#+begin_src moonli
(if a: b else: c; end)::boolean
#+end_src

transpiles to

#+begin_src common-lisp
(the boolean (cond (a b) (t c)))
#+end_src

#+begin_src moonli
if null(args): 0; else: 1 end
#+end_src

transpiles to

#+begin_src common-lisp
(cond ((null args) 0) (t 1))
#+end_src

#+begin_src moonli
if null(args):
    0
else:
    first(args)
end if
#+end_src

transpiles to

#+begin_src common-lisp
(cond ((null args) 0) (t (first args)))
#+end_src

#+begin_src moonli
if null(args):
  0
else:
  2 + 3
end if
#+end_src

transpiles to

#+begin_src common-lisp
(cond ((null args) 0) (t (+ 2 3)))
#+end_src

#+begin_src moonli
if null(args):
  0
else:
  first(args) + add(rest(args))
end if
#+end_src

transpiles to

#+begin_src common-lisp
(cond ((null args) 0) (t (+ (first args) (add (rest args)))))
#+end_src


** let
:PROPERTIES:
:CUSTOM_ID: let
:END:


#+begin_src moonli
let a = 2, b = 3:
   a + b
end
#+end_src

transpiles to

#+begin_src common-lisp
(let ((a 2) (b 3))
  (+ a b))
#+end_src

#+begin_src moonli
let a = 2, b = 3:
   a + b
end let
#+end_src

transpiles to

#+begin_src common-lisp
(let ((a 2) (b 3))
  (+ a b))
#+end_src

** for:for
:PROPERTIES:
:CUSTOM_ID: forfor
:END:

#+begin_src moonli
for:for (i,j) in ((1,2),(3,4)):
  print(i + j)
end
#+end_src

transpiles to

#+begin_src common-lisp
(for (((i j) in (list (list 1 2) (list 3 4))))
  (print (+ i j)))
#+end_src

#+begin_src moonli
for:for i in (1,2,3), j in (2,3,4):
  print(i + j)
end
#+end_src

transpiles to

#+begin_src common-lisp
(for ((i in (list 1 2 3)) (j in (list 2 3 4)))
  (print (+ i j)))
#+end_src
