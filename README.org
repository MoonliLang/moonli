#+title: Moonli - Algol-style syntax that transpiles to Common Lisp

#+begin_quote
Status: Explorative (pre-experimental). It is NOT ready for use in any project, not even if it is a throwaway project.
#+end_quote

* What
:PROPERTIES:
:CUSTOM_ID: what
:END:

This is a syntax layer that transpiles to Common Lisp.

#+begin_src 
defun sum(args):
  if null(args):
    0
  else:
    first(args) + sum(rest(args))
  end
end
#+end_src

transpiles to:

#+begin_src lisp
(defun sum (args)
   (cond ((null args)
          0)
         (t
          (+ (first args)
             (sum (rest args))))))
#+end_src

See [[./moonli-sample.asd]] and [[./sample/sample.moonli]] to include in your project.

#+attr_html: :width 640px
[[./repl/repl.gif]]

* Table of Contents
:PROPERTIES:
:TOC:      :include all :depth 4
:CUSTOM_ID: table-of-contents
:END:

:CONTENTS:
- [[#what][What]]
- [[#table-of-contents][Table of Contents]]
- [[#why][Why]]
- [[#features][Features]]
  - [[#for-lispers][For lispers]]
  - [[#for-programmers-in-general][For programmers in general]]
- [[#installation][Installation]]
  - [[#binaries---trial-basis][Binaries - Trial Basis]]
  - [[#from-fresh-compilers][From fresh compilers]]
    - [[#0-install-a-package-manager][0. Install a package manager]]
    - [[#1-install-a-compiler-and-some-tools][1. Install a compiler and some tools]]
    - [[#2-install-ocicl][2. Install ocicl]]
    - [[#3-moonli][3. Moonli]]
- [[#plan][Plan]]
- [[#syntax][Syntax]]
  - [[#global-variables][Global variables]]
  - [[#local-variables][Local variables]]
  - [[#symbols][Symbols]]
  - [[#function-like-calls][Function-like calls]]
  - [[#functions][Functions]]
  - [[#dictionaries-or-hash-tables][Dictionaries or Hash-tables]]
  - [[#sets-or-hash-sets][Sets or Hash-sets]]
  - [[#infix-operators][Infix operators]]
:END:


* Why
:PROPERTIES:
:CUSTOM_ID: why
:END:

Due to tools like [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][paredit]] and [[https://github.com/abo-abo/lispy][lispy]] (beyond [[https://lispcookbook.github.io/cl-cookbook/macros.html][macros]] and metaprogramming), s-expression (Lists) based syntax of lisps is very powerful. However, not every one has the time or patience to become comfortable with them, especially when it comes to reading code, or sharing it with your colleagues.

In the 21st century, very many more people are familiar with python, matlab and julia than they are with lisps. Given the power and flexibility of common lisp, =moonli= is an attempt to provide a thin syntax layer over common lisp. It is thin in the sense it can be easily transpiled to common lisp. The semantics remain the same and clean as common lisp. ([[https://common-lisp.net/][Common Lisp]] is also good for [[https://www.quora.com/What-is-your-favourite-non-mainstream-programming-language/answer/Shubhamkar-Ayare][reasons beyond macros]].)

* Features
:PROPERTIES:
:CUSTOM_ID: features
:END:

** For common lispers
:PROPERTIES:
:CUSTOM_ID: for-lispers
:END:

- Case sensitive, but invert-case reader to maintain common lisp compatibility
- Transpile to common lisp, so lispers need not "learn a new language"
- Extensible using =moonli:define-moonli-macro= and =moonli:define-short-moonli-macro=. See [[./src/macros/]] directory for examples.
- Inability to access internal symbols of another package through "A::B" syntax; this syntax rather translates to =(the B A)=

** For programmers in general
:PROPERTIES:
:CUSTOM_ID: for-programmers-in-general
:END:

- Sane variable scoping rules as given by common lisp
- Sane namespace scoping thanks to common lisp package system
- Sane restarts and condition system thanks to common lisp
- Optional typing, optional dynamic scoping
- Availability of optimizing compilers such as SBCL
- Sensitive to newlines and semicolons but not to spaces and tabs (indentation insensitive)
- Returning multiple values without an intermediate data structure
- Support for rapid prototyping through CLOS and image-based development

Here's a brief comparison of features across different languages.

| *Features*                          |  *Moonli*  | *Common Lisp* |   *Julia*   |  *Haskell*  |     *Rust*     |  *Python*   | *Javascript* |     *C*     |
|                                   |   <c>    |     <c>     |    <c>    |    <c>    |     <c>      |    <c>    |    <c>     |    <c>    |
|-----------------------------------+----------+-------------+-----------+-----------+--------------+-----------+------------+-----------|
| Syntax                            |    +     |      +      |     +     |     +     |     ---      |     +     |     -      |     -     |
| Interactivity (Rapid Prototyping) |   High   |  Very High  | Moderate  |    Low    |     None     | Moderate  |  Moderate  |   None    |
| Typing (Strong/Weak)              |  Strong  |   Strong    |  Strong   |  Strong   |    Strong    |  Strong   |    Weak    |   Weak    |
| Typing (Static/Dynamic)           | Flexible |  Flexible   | Flexible  |  Static   |    Static    |  Dynamic  |  Dynamic   |  Dynamic  |
| Typing (Expressivity)             | Flexible |  Flexible   | Moderate  | Very High |  Very High   |    Low    |    Low     |    Low    |
| Compiler Speed                    | Flexible |  Flexible   |   Slow    | Moderate  |     Slow     | Moderate  |  Moderate  | Moderate  |
| Runtime Speed                     | Flexible |  Flexible   |   Fast    | Moderate  |     Fast     |   Slow    |  Moderate  |   Fast    |
| Runtime Error Recovery            | Advanced |  Advanced   |  Limited  | Moderate  |     None     | Moderate  |  Moderate  |   None    |
| Binary Size                       | Flexible |  Flexible   |   Large   |     ?     |    Small     |   None    |    None    |   Small   |
| User Extensibility                |   High   |    High     | Moderate  |    Low    |     Low      |   None    |    None    |   None    |
| Compiler built-in optimizations   |   Low    |     Low     | Very High |     ?     |  Very High   |    Low    |  Moderate  | Very High |
| Long Term Support                 |   Low    |  Very High  | Moderate  |     ?     |   Moderate   | Moderate  |    Low     | Very High |
| Ecosystem (without interop)       |  Small   |    Small    | Moderate  |   Small   |   Moderate   |   Large   |   Large    |   Large   |
| Memory Management                 |   Heap   |    Heap     | Reference |   Heap    | Compile Time | Reference |     ?      |  Manual   |

* Installation
:PROPERTIES:
:CUSTOM_ID: installation
:END:

** Binaries - Trial Basis
:PROPERTIES:
:CUSTOM_ID: binaries---trial-basis
:END:

Grab a binary from the [[https://github.com/digikar99/moonli/releases/latest][latest release]]. If you want an interactive REPL as in the above gif, grab the binaries with "cl-repl" in their name. 

If you want to run a few moonli files, grab the regular binaries.

However, the cl-repl binaries depend on readline. This can be installed as follows:

- Ubuntu: =sudo apt install libreadline-dev=
- Mac OS: =brew link readline --force=
- Windows: =pacman -S mingw-w64-x86_64-readline=

In case of any installation issues, please create an issue on [[https://github.com/digikar99/moonli/issues/new][github]] or [[https://gitlab.com/digikar/moonli/-/issues/new?type=ISSUE][gitlab]].

** From fresh compilers
:PROPERTIES:
:CUSTOM_ID: from-fresh-compilers
:END:

*** 0. Install a package manager
:PROPERTIES:
:CUSTOM_ID: 0-install-a-package-manager
:END:

Mac OS: [[https://brew.sh/][brew]]

#+begin_src
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
#+end_src

Windows: 

- [[https://www.msys2.org/][MSYS2]]: this will install the =pacman= package manager
- Or [[https://chocolatey.org/install][choco]]

*** 1. Install a compiler and some tools
:PROPERTIES:
:CUSTOM_ID: 1-install-a-compiler-and-some-tools
:END:

- Ubuntu: =sudo apt install git sbcl=
- Mac OS: =brew install git sbcl=
- Windows:
  - =pacman -S git mingw-w64-x86_64-sbcl=
  - =choco install git sbcl=

Once this step is successful, you should be able to type =sbcl --help= and see something similar to the following:

#+begin_src
Usage: sbcl [runtime-options] [toplevel-options] [user-options]
Common runtime options:
  --help                     Print this message and exit.
  --version                  Print version information and exit.
  --core <filename>          Use the specified core file instead of the default.
  --dynamic-space-size <MiB> Size of reserved dynamic space in megabytes.
  --control-stack-size <MiB> Size of reserved control stack in megabytes.
  --tls-limit                Maximum number of thread-local symbols.

Common toplevel options:
  --sysinit <filename>       System-wide init-file to use instead of default.
  --userinit <filename>      Per-user init-file to use instead of default.
  --no-sysinit               Inhibit processing of any system-wide init-file.
  --no-userinit              Inhibit processing of any per-user init-file.
  --disable-debugger         Invoke sb-ext:disable-debugger.
  --noprint                  Run a Read-Eval Loop without printing results.
  --script [<filename>]      Skip #! line, disable debugger, avoid verbosity.
  --quit                     Exit with code 0 after option processing.
  --non-interactive          Sets both --quit and --disable-debugger.
Common toplevel options that are processed in order:
  --eval <form>              Form to eval when processing this option.
  --load <filename>          File to load when processing this option.

User options are not processed by SBCL. All runtime options must
appear before toplevel options, and all toplevel options must
appear before user options.

For more information please refer to the SBCL User Manual, which
should be installed along with SBCL, and is also available from the
website <http://www.sbcl.org/>.
#+end_src

*** 2. Install ocicl
:PROPERTIES:
:CUSTOM_ID: 2-install-ocicl
:END:

Follow the instructions at https://github.com/ocicl/ocicl.

Briefly:

- MacOS: =brew install ocicl && ocicl setup=
- Others:

#+begin_src
git clone https://github.com/ocicl/ocicl
cd ocicl
sbcl --load setup.lisp
ocicl setup
#+end_src

Edit the compiler init file (eg. =~/.sbclrc=) to include the current directory, or

#+begin_src lisp
#-ocicl
(when (probe-file #P"/Users/user/.local/share/ocicl/ocicl-runtime.lisp")
  (load #P"/Users/user/.local/share/ocicl/ocicl-runtime.lisp"))
(asdf:initialize-source-registry
 ;; (list :source-registry
 ;;       (list :tree (uiop:strcat (uiop:getenv "HOME") "/Common Lisp/"))
 ;;       :inherit-configuration)
 (list :source-registry
       (list :directory (uiop:getcwd))
       :inherit-configuration))
#+end_src

*** 3. Moonli
:PROPERTIES:
:CUSTOM_ID: 3-moonli
:END:

**** 3.1. Obtain the source
:PROPERTIES:
:CUSTOM_ID: 1-obtain-the-source
:END:

#+begin_src
git clone https://github.com/digikar99/moonli
#+end_src

**** 3.2. Start the REPL
:PROPERTIES:
:CUSTOM_ID: 2-start-the-repl
:END:

#+begin_src
sbcl --eval '(asdf:load-system "moonli-repl")' --eval '(cl-repl:main)'
#+end_src

**** 3.3a. (Optional) Building basic binary
:PROPERTIES:
:CUSTOM_ID: 3a-optional-building-basic-binary
:END:

The following should create a =moonli= binary in the root directory of moonli.

#+begin_src lisp
(asdf:make :moonli)
#+end_src

#+begin_src
./moonli --help
A basic moonli transpiler over SBCL
Available options:
  -h, --help                 Print this help text
  -l, --load-lisp ARG        Load lisp file
  -m, --load-moonli ARG      Load moonli file
  -t, --transpile-moonli ARG
                             Transpile moonli file to lisp file
#+end_src

**** 3.3b. (Optional) Build REPL
:PROPERTIES:
:CUSTOM_ID: 3b-optional-build-repl
:END:

The following should create a =cl-repl.moonli= binary in the root directory of moonli.

#+begin_src lisp
(asdf:make :moonli-repl)
#+end_src

* Plan
:PROPERTIES:
:CUSTOM_ID: plan
:END:

- DONE Real numbers, strings, characters, lists, infix arithmetic operators, literal hash-tables, literal hash-sets
- DONE Typing using "expr::type" operator
- DONE Support for declare and declaim
- TODO Literal syntax for vectors, array access
- DONE BODMAS rule for parsing expressions
- DONE Binaries
- TODO VS Code integration
- TODO Emacs mode and integration with slime
- DONE Infix Logical operators
- TODO Add more forms: progn, mvb, dsb, let+, more...
- TODO Add more tests
- TODO Reverse transpile from common lisp

* Syntax
:PROPERTIES:
:CUSTOM_ID: syntax
:END:

As with lisp, everything is an expression.

Simple syntax table:

| Lisp                     | Moonli                  |
|--------------------------+-------------------------|
| #\a                      | 'a'                     |
| "hello world"            | "hello world"           |
| 2, 2.0, 2d-3, 2.0d-3     | 2, 2.0, 2d-3, 2.0d-3    |
| 'quoted-symbol           | $quoted-symbol          |
| package:exported-symbol  | package:exported-symbol |
| package::internal-symbol | <WONTDO>                |
| (the type expr)          | expr :: type            |
| (list form-1 form-2)     | (form-1, form-2)        |
| (fn arg1 arg2)           | fn(arg1, arg2)          |
| #c(re, im)               | <TODO>                  |

** Global variables
:PROPERTIES:
:CUSTOM_ID: global-variables
:END:

#+begin_src moonli
defparameter *global* = 23
#+end_src

** Local variables
:PROPERTIES:
:CUSTOM_ID: local-variables
:END:

#+begin_src moonli
let answer-to-everything = 42 :
  answer-to-everything
end
#+end_src

** Symbols
:PROPERTIES:
:CUSTOM_ID: symbols
:END:

Most valid symbols can be written in moonli. For example, above =*global*= and =answer-to-everything= are each single symbols. This is unlike mainstream languages where =* - ? != and several other characters are not allowed in symbols.

However, this means that symbols must be separated from each other by space. This is necessary to make a distinction between whether a character stands for an infix operation or is part of a symbol. =a+b= is a single symbol, but =a + b= is translated to the lisp expression =(+ a b)=.

** Function-like calls
:PROPERTIES:
:CUSTOM_ID: function-like-calls
:END:

#+begin_src moonli
identity("hello world")
function(identity)
#+end_src

Because lisp macros and functions follow similar syntax, moonli syntax for function calls can also be used for macro calls when the macro syntax is simple. (Indeed, this can be inconvenient; see [[defining your own]].)

#+begin_src moonli
destructuring-bind(a(b),(1,2),+(1,2))
#+end_src

transpiles to

#+begin_src lisp
(destructuring-bind (a b) (list 1 2)
  (+ 1 2))
#+end_src

** Functions
:PROPERTIES:
:CUSTOM_ID: functions
:END:

Like lisp, return is implicit.

#+begin_src moonli
defun fib(n):
  if n < 0:
     error("Don't know how to compute fib for n=~d < 0", n)
  elif n == 0 or n == 1:
     1
  else:
    fib(n-1) + fib(n-2)
  end
end
#+end_src

** Dictionaries or Hash-tables
:PROPERTIES:
:CUSTOM_ID: dictionaries-or-hash-tables
:END:

#+begin_src moonli
{
  :a : 2,
  "b": $cl:progn
}
#+end_src

transpiles to

#+begin_src lisp
(fill-hash-table (:a 2) ("b" 'progn))
#+end_src

which expands to

#+begin_src lisp
(let ((#:hash-table413 (make-hash-table :test #'equal :size 2)))
  (setf (gethash :a #:hash-table413) 2
        (gethash "b" #:hash-table413) 'progn)
  #:hash-table413)
#+end_src

** Sets or Hash-sets
:PROPERTIES:
:CUSTOM_ID: sets-or-hash-sets
:END:

#+begin_src moonli
{:a, "b" , $cl:progn}
#+end_src

transpiles to

#+begin_src lisp
(fill-hash-set :a "b" 'progn)
#+end_src

which expands to

#+begin_src lisp
(let ((#:hash-set417 (make-hash-table :test #'equal :size 3)))
  (setf (gethash :a #:hash-set417) t
        (gethash "b" #:hash-set417) t
        (gethash 'progn #:hash-set417) t)
  #:hash-set417)
#+end_src

** Infix operators
:PROPERTIES:
:CUSTOM_ID: infix-operators
:END:

The following infix operators are recognized:

- =+ - * / ^=
- =or and not=
- < <= == != >= > 
