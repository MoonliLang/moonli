#+title: Moonli - Algol-style syntax that transpiles to Common Lisp

#+begin_quote
Status: Explorative (pre-experimental). It is NOT ready for use in any project, not even if it is a throwaway project.
#+end_quote

* What

This is a syntax layer that transpiles to Common Lisp.

#+begin_src 
defun add(&rest, args):
  if null(args):
    0
  else:
    first(args) + add(rest(args))
  end
end
#+end_src

transpiles to:

#+begin_src lisp
(defun add (&rest args)
  (if (null args)
      0
      (+ (first args)
         (add (rest args)))))
#+end_src

See [[./moonli-sample.asd]] and [[./sample/sample.moonli]] to include in your project.

#+attr_html: :width 640px
[[./repl/repl.gif]]

* Why

I love s-expression based syntaxes of lisps, particularly because of tools like [[http://danmidwood.com/content/2014/11/21/animated-paredit.html][paredit]] and [[https://github.com/abo-abo/lispy][lispy]], as well as [[https://lispcookbook.github.io/cl-cookbook/macros.html][macros]]. But I also acknowledge not every one has the time or patience to become comfortable with them, especially when it comes to reading code.

I also love [[https://common-lisp.net/][Common Lisp]] for [[https://www.quora.com/What-is-your-favourite-non-mainstream-programming-language/answer/Shubhamkar-Ayare][reasons beyond macros]].

Yet, in the 21st century, it is a fact that very many more people are familiar with python, matlab and julia than they are with lisps. Given the power and flexibility of common lisp, my ambitious plan is to get all mainstream languages to transpile to common lisp. The more realistic plan is to create and maintain the "Moonli" syntax layer in this repository.

* Features

** For lispers

- Case sensitive, but invert-case reader to maintain common lisp compatibility
- Transpile to common lisp, so lispers need not "learn a new language"
- Extensible using =moonli:define-moonli-macro= and =moonli:define-short-moonli-macro=. See [[./src/macros/]] directory for examples.
- Inability to access internal symbols of another package through "A::B" syntax; this syntax rather translates to =(the B A)=

** For programmers in general

- Sane variable scoping rules as given by common lisp
- Sane namespace scoping thanks to common lisp package system
- Sane restarts and condition system thanks to common lisp
- Optional typing, optional dynamic scoping
- Availability of optimizing compilers such as SBCL
- Sensitive to newlines and semicolons but not to spaces and tabs (indentation insensitive)
- Returning multiple values without an intermediate data structure
- Support for rapid prototyping through CLOS and image-based development

* Installation

** 1. Install SBCL (or CCL or another Common Lisp compiler or interpreter)

*** Mac OS

#+begin_src
brew install sbcl
#+end_src

** 2. Install ocicl

*** Mac OS

#+begin_src
brew install ocicl
ocicl setup
#+end_src

Edit the lisp startup file (eg. =~/.sbclrc=) to include the current directory, or

#+begin_src lisp
#-ocicl
(when (probe-file #P"/Users/user/.local/share/ocicl/ocicl-runtime.lisp")
  (load #P"/Users/user/.local/share/ocicl/ocicl-runtime.lisp"))
(asdf:initialize-source-registry
  ;; (list :source-registry (list :directory (uiop:getcwd)) :inherit-configuration)
 (list :source-registry
       (list :tree (uiop:strcat (uiop:getenv "HOME") "/Common Lisp/"))
       :inherit-configuration))
#+end_src

** 3. Install moonli

*** Build REPL

The following should create a =moonli= binary in the root directory of moonli.

#+begin_src lisp
(asdf:make :moonli-repl)
#+end_src

* Plan

- DONE Real numbers, strings, characters, lists, infix arithmetic operators, literal hash-tables, literal hash-sets
- DONE Typing using "expr::type" operator
- TODO Support for declare and declaim
- TODO Literal syntax for vectors, array access
- DONE BODMAS rule for parsing expressions
- TODO VS Code integration
- TODO Emacs mode and integration with slime
- TODO Infix Logical operators
- TODO Add more forms: progn, mvb, dsb, let+, more...
- TODO Add more tests
- TODO Reverse transpile from common lisp


