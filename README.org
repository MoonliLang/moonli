#+title: Moonli Programming Language

#+begin_quote
Status: Explorative (pre-experimental). It is NOT ready for use in any project, not even if it is a throwaway project.

If you are a lisper, see [[file:README-CL.org]].
#+end_quote

Moonli is a beautiful programming language with a simple syntax and a very interactive development experience. This enables rapidly prototyping new programs. At the same time, once a prototype is ready, the programs can also be optimized for runtime performance as well as long term maintenance.

* Table of Contents
:PROPERTIES:
:TOC:      :include all :depth 3 :ignore this
:CUSTOM_ID: table-of-contents
:END:

:CONTENTS:
- [[#installation][Installation]]
  - [[#binaries][Binaries]]
  - [[#from-fresh-compilers][From fresh compilers]]
    - [[#0-install-a-package-manager][0. Install a package manager]]
    - [[#1-install-a-compiler-and-some-tools][1. Install a compiler and some tools]]
    - [[#2-install-ocicl][2. Install ocicl]]
    - [[#3-moonli][3. Moonli]]
- [[#a-short-tutorial][A Short Tutorial]]
  - [[#global-variables][Global variables]]
  - [[#local-variables][Local variables]]
  - [[#symbols][Symbols]]
  - [[#function-like-calls][Function-like calls]]
  - [[#functions][Functions]]
  - [[#dictionaries-or-hash-tables][Dictionaries or Hash-tables]]
  - [[#sets-or-hash-sets][Sets or Hash-sets]]
  - [[#infix-operators][Infix operators]]
  - [[#lm][lm]]
  - [[#declaim][declaim]]
  - [[#declare][declare]]
  - [[#ifelse][ifelse]]
  - [[#lambda][lambda]]
  - [[#let][let+]]
  - [[#loop][loop]]
  - [[#defun][defun]]
  - [[#if][if]]
  - [[#let-0][let]]
:END:


* Installation
:PROPERTIES:
:CUSTOM_ID: installation
:END:

** Binaries
:PROPERTIES:
:CUSTOM_ID: binaries
:END:

Grab a binary from the [[https://github.com/digikar99/moonli/releases/latest][latest release]]. If you want an interactive REPL as in the above gif, grab the binaries with "repl" in their name. 

If you want to run a few moonli files, grab the regular binaries.

However, the repl binaries depend on readline. This can be installed as follows:

- Ubuntu: =sudo apt install libreadline-dev=
- Mac OS: =brew link readline --force=
- Windows: =pacman -S mingw-w64-x86_64-readline=

In case of any installation issues, please create an issue on [[https://github.com/digikar99/moonli/issues/new][github]] or [[https://gitlab.com/digikar/moonli/-/issues/new?type=ISSUE][gitlab]].

** From fresh compilers
:PROPERTIES:
:CUSTOM_ID: from-fresh-compilers
:END:

*** 0. Install a package manager
:PROPERTIES:
:CUSTOM_ID: 0-install-a-package-manager
:END:

Mac OS: [[https://brew.sh/][brew]]

#+begin_src
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
#+end_src

Windows: 

- [[https://www.msys2.org/][MSYS2]]: this will install the =pacman= package manager
- Or [[https://chocolatey.org/install][choco]]

*** 1. Install a compiler and some tools
:PROPERTIES:
:CUSTOM_ID: 1-install-a-compiler-and-some-tools
:END:

- Ubuntu: =sudo apt install git sbcl=
- Mac OS: =brew install git sbcl=
- Windows:
  - =pacman -S git mingw-w64-x86_64-sbcl=
  - =choco install git sbcl=

Once this step is successful, you should be able to type =sbcl --help= and see something similar to the following:

#+begin_src
Usage: sbcl [runtime-options] [toplevel-options] [user-options]
Common runtime options:
  --help                     Print this message and exit.
  --version                  Print version information and exit.
  --core <filename>          Use the specified core file instead of the default.
  --dynamic-space-size <MiB> Size of reserved dynamic space in megabytes.
  --control-stack-size <MiB> Size of reserved control stack in megabytes.
  --tls-limit                Maximum number of thread-local symbols.

Common toplevel options:
  --sysinit <filename>       System-wide init-file to use instead of default.
  --userinit <filename>      Per-user init-file to use instead of default.
  --no-sysinit               Inhibit processing of any system-wide init-file.
  --no-userinit              Inhibit processing of any per-user init-file.
  --disable-debugger         Invoke sb-ext:disable-debugger.
  --noprint                  Run a Read-Eval Loop without printing results.
  --script [<filename>]      Skip #! line, disable debugger, avoid verbosity.
  --quit                     Exit with code 0 after option processing.
  --non-interactive          Sets both --quit and --disable-debugger.
Common toplevel options that are processed in order:
  --eval <form>              Form to eval when processing this option.
  --load <filename>          File to load when processing this option.

User options are not processed by SBCL. All runtime options must
appear before toplevel options, and all toplevel options must
appear before user options.

For more information please refer to the SBCL User Manual, which
should be installed along with SBCL, and is also available from the
website <http://www.sbcl.org/>.
#+end_src

*** 2. Install ocicl
:PROPERTIES:
:CUSTOM_ID: 2-install-ocicl
:END:

Follow the instructions at https://github.com/ocicl/ocicl.

Briefly:

- MacOS: =brew install ocicl && ocicl setup=
- Others:

#+begin_src
git clone https://github.com/ocicl/ocicl
cd ocicl
sbcl --load setup.lisp
ocicl setup
#+end_src

Edit the compiler init file (eg. =~/.sbclrc=) to include the current directory, or

#+begin_src lisp
#-ocicl
(when (probe-file #P"/Users/user/.local/share/ocicl/ocicl-runtime.lisp")
  (load #P"/Users/user/.local/share/ocicl/ocicl-runtime.lisp"))
(asdf:initialize-source-registry
 ;; (list :source-registry
 ;;       (list :tree (uiop:strcat (uiop:getenv "HOME") "/Common Lisp/"))
 ;;       :inherit-configuration)
 (list :source-registry
       (list :directory (uiop:getcwd))
       :inherit-configuration))
#+end_src

*** 3. Moonli
:PROPERTIES:
:CUSTOM_ID: 3-moonli
:END:

**** 3.1. Obtain the source
:PROPERTIES:
:CUSTOM_ID: 1-obtain-the-source
:END:

#+begin_src
git clone https://github.com/digikar99/moonli
#+end_src

**** 3.2. Start the REPL
:PROPERTIES:
:CUSTOM_ID: 2-start-the-repl
:END:

#+begin_src
sbcl --eval '(asdf:load-system "moonli-repl")' --eval '(cl-repl:main)'
#+end_src

**** 3.3a. (Optional) Building basic binary
:PROPERTIES:
:CUSTOM_ID: 3a-optional-building-basic-binary
:END:

The following should create a =moonli= binary in the root directory of moonli.

#+begin_src lisp
(asdf:make :moonli)
#+end_src

#+begin_src
./moonli --help
A basic moonli transpiler over SBCL
Available options:
  -h, --help                 Print this help text
  -l, --load-lisp ARG        Load lisp file
  -m, --load-moonli ARG      Load moonli file
  -t, --transpile-moonli ARG
                             Transpile moonli file to lisp file
#+end_src

**** 3.3b. (Optional) Build REPL
:PROPERTIES:
:CUSTOM_ID: 3b-optional-build-repl
:END:

The following should create a =cl-repl.moonli= binary in the root directory of moonli.

#+begin_src lisp
(asdf:make :moonli-repl)
#+end_src


* A Short Tutorial
:PROPERTIES:
:CUSTOM_ID: a-short-tutorial
:END:

Moonli follows the idiom "everything is an expression". Thus, one does not need to worry about statements and expressions.

The simplest moonli program consists of a single expression. For example, entering the string ="Hello, world!"= at the REPL will return the same value.

#+begin_src
MOONLI-USER> "Hello, world!"

[OUT]: "Hello, world!"
#+end_src

You can also create a =tutorial.moonli= file with the contents

#+begin_src
"Hello, world!"
#+end_src

And then run it using =moonli tutorial.moonli=. You will note that it does not produce any output. The expression ~"Hello, world!"~ /evaluates/ to ="Hello, world!"=, but it does not write anything to the output. To write to the output, we can call the ~format~ function.

#+begin_src
MOONLI-USER> format(t, "Hello, world!")
Hello, world!
[OUT]: NIL
#+end_src

This writes to the output, but returns a value ~NIL~. This is a special value with multiple meanings, but essentially, it corresponds to "nothing".

** Global variables
:PROPERTIES:
:CUSTOM_ID: global-variables
:END:

#+begin_src moonli
defparameter *global* = 23
#+end_src

** Local variables
:PROPERTIES:
:CUSTOM_ID: local-variables
:END:

#+begin_src moonli
let answer-to-everything = 42 :
  answer-to-everything
end
#+end_src

** Symbols
:PROPERTIES:
:CUSTOM_ID: symbols
:END:

Most valid symbols can be written in moonli. For example, above =*global*= and =answer-to-everything= are each single symbols. This is unlike mainstream languages where =* - ? != and several other characters are not allowed in symbols.

However, this means that symbols must be separated from each other by space. This is necessary to make a distinction between whether a character stands for an infix operation or is part of a symbol. =a+b= is a single symbol, but =a + b= is translated to the lisp expression =(+ a b)=.

** Function-like calls
:PROPERTIES:
:CUSTOM_ID: function-like-calls
:END:

#+begin_src moonli
identity("hello world")
function(identity)
#+end_src

** Functions
:PROPERTIES:
:CUSTOM_ID: functions
:END:

Like lisp, return is implicit.

#+begin_src moonli
defun fib(n):
  if n < 0:
     error("Don't know how to compute fib for n=~d < 0", n)
  elif n == 0 or n == 1:
     1
  else:
    fib(n-1) + fib(n-2)
  end
end
#+end_src

** Dictionaries or Hash-tables
:PROPERTIES:
:CUSTOM_ID: dictionaries-or-hash-tables
:END:

#+begin_src moonli
{
  :a : 2,
  "b": $cl:progn
}
#+end_src

** Sets or Hash-sets
:PROPERTIES:
:CUSTOM_ID: sets-or-hash-sets
:END:

#+begin_src moonli
{:a, "b" , $cl:progn}
#+end_src

** Infix operators
:PROPERTIES:
:CUSTOM_ID: infix-operators
:END:

The following infix operators are recognized:

- =+ - * / ^=
- =or and not=
- < <= == != >= > 

** lm
:PROPERTIES:
:CUSTOM_ID: lm
:END:

#+begin_src moonli
lm (): nil

lm (x): x

lm (x, y): x + y
#+end_src

** declaim
:PROPERTIES:
:CUSTOM_ID: declaim
:END:

#+begin_src moonli
declaim inline(foo)

declaim type(hash-table, *map*)
#+end_src

** declare
:PROPERTIES:
:CUSTOM_ID: declare
:END:

#+begin_src moonli
declare type(single-float, x, y)

declare type(single-float, x, y), optimize(debug(3))
#+end_src

** ifelse
:PROPERTIES:
:CUSTOM_ID: ifelse
:END:

#+begin_src moonli
ifelse a 5

ifelse a :hello :bye
#+end_src


** lambda
:PROPERTIES:
:CUSTOM_ID: lambda
:END:

#+begin_src moonli
lambda (): nil end

lambda (x):
  x
end

lambda (x, y):
  let sum = x + y:
    sum ^ 2
  end
end
#+end_src

** let+
:PROPERTIES:
:CUSTOM_ID: let
:END:

#+begin_src moonli
let-plus:let+ x = 42: x
end

let-plus:let+ (a,b) = list(1,2):
  a + b
end

let-plus:let+ let-plus:&values(a,b) = list(1,2):
  a + b
end

let-plus:let+
  let-plus:&values(a,b) = list(1,2),
  (c,d,e) = list(1,2,3):
  {a,b,c,d,e}
end
#+end_src

** loop
:PROPERTIES:
:CUSTOM_ID: loop
:END:

#+begin_src moonli
loop end loop

loop :repeat n :do
  print("hello")
end

loop :for i :below n :do
  print(i + 1)
end
#+end_src

** defun
:PROPERTIES:
:CUSTOM_ID: defun
:END:

#+begin_src moonli
defun our-identity(x): x end

defun add (&rest, args):
 args
end defun

defun add(args):
  if null(args):
    0
  else:
    first(args) + add(rest(args))
  end if
end

defun foo(&optional, a = 5): a end
#+end_src

** if
:PROPERTIES:
:CUSTOM_ID: if
:END:

#+begin_src moonli
if a: b end if

if a:
  b; c
end

if a: b
else: c
end if

if a:
   b; d
else:
   c; e
end if

if a: b
elif c: d; e
else: f
end if

(if a: b else: c; end)::boolean

if null(args): 0; else: 1 end

if null(args):
    0
else:
    first(args)
end if

if null(args):
  0
else:
  2 + 3
end if

if null(args):
  0
else:
  first(args) + add(rest(args))
end if
#+end_src

** let
:PROPERTIES:
:CUSTOM_ID: let-0
:END:

#+begin_src moonli
let a = 2, b = 3:
   a + b
end

let a = 2, b = 3:
   a + b
end let
#+end_src
